<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Setup your own Android Bluetooth Low Energy Server part 1</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Setup your own Android Bluetooth Low Energy Server part 1</h1>
</header>
<section data-field="subtitle" class="p-summary">
This article series is about an app that serves your own Bluetooth Low Energy (BLE) server but not about the basic technology itself. If…
</section>
<section data-field="body" class="e-content">
<section name="4022" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ff5c" id="ff5c" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">Setup your own Android Bluetooth Low Energy Server part 1</strong></h3><p name="e187" id="e187" class="graf graf--p graf-after--h3">This article series is about an app that serves your own Bluetooth Low Energy (BLE) server but not about the basic technology itself. If you need more information and a deep look into Bluetooth Low Energy I recommend this article: “The Ultimate Guide to Android Bluetooth Low Energy“ (<a href="https://punchthrough.com/android-ble-guide/" data-href="https://punchthrough.com/android-ble-guide/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://punchthrough.com/android-ble-guide/</a>).</p><p name="da3e" id="da3e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Why do we need a self programmed BLE server or peripheral ?</strong> A own server is useful when developing an app that connects to a BLE device like a Heart Rate monitor but such a device is not available at that time of development.</p><p name="7f6f" id="7f6f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What do I need to follow the article ?</strong> You should use a modern Android Studio system (as of year 2022) and have 2 Android smartphones (SDK min 21) with Bluetooth capabilities to run the server on one and a client on the other smartphone. I’m using Java to run my server but the code can easily converted to Kotlin with Android Studio. To get a professional view on the server and the services provided I recommend that you install a client app on your second device, my first choice is „nRF Connect for Mobile“ and it is available in the PlayStore: „<a href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=de&amp;gl=US" data-href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=de&amp;gl=US" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=de&amp;gl=US</a>&quot;. If you should need a simple manual for the app you can find it here on medium.com: <a href="https://medium.com/@androidcrypto/connect-the-android-nrf-connect-mobile-app-with-a-bluetooth-low-energy-device-8ba900d70286" data-href="https://medium.com/@androidcrypto/connect-the-android-nrf-connect-mobile-app-with-a-bluetooth-low-energy-device-8ba900d70286" class="markup--anchor markup--p-anchor" rel="nofollow" target="_blank">https://medium.com/@androidcrypto/connect-the-android-nrf-connect-mobile-app-with-a-bluetooth-low-energy-device-8ba900d70286</a>.</p><p name="eca7" id="eca7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How do we start ?</strong> Unfortunately there is less information about programming the server on the official Android Developer sites and the connectivity-samples on GitHub (<a href="https://github.com/android/connectivity-samples" data-href="https://github.com/android/connectivity-samples" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/android/connectivity-samples</a>) are not very helpful for this task.</p><p name="9a66" id="9a66" class="graf graf--p graf-after--p">I was very happy to find the library <strong class="markup--strong markup--p-strong">blessed-android</strong> (https://github.com/weliem/blessed-android) from <strong class="markup--strong markup--p-strong">Martijn van Welie</strong> that has an actual and running example for a BLE server and client. This article series is based on this library that’s main purpose is to develop a BLE client.</p><p name="8fb2" id="8fb2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Why do I use a library for BLE and don’t use the pure BLE apis ?</strong> There are many reasons but the most important point is that the blessed-android library supports <strong class="markup--strong markup--p-strong">queueing of commands</strong>. As the BLE apis run a-synchronic you have to wait until a read or write command is delivered before submitting the next command. This can lead to an unexpected behavior and errors — better use the recommend library.</p><p name="761f" id="761f" class="graf graf--p graf-after--p">The library comes with a sample measurement app and there is a companion article series that covers the <strong class="markup--strong markup--p-strong">setup of a Android Bluetooth Low Energy Client: </strong><a href="https://medium.com/@androidcrypto/setup-a-android-bluetooth-low-energy-client-part-1-70f0eea9149b" data-href="https://medium.com/@androidcrypto/setup-a-android-bluetooth-low-energy-client-part-1-70f0eea9149b" class="markup--anchor markup--p-anchor" target="_blank">https://medium.com/@androidcrypto/setup-a-android-bluetooth-low-energy-client-part-1-70f0eea9149b</a>.</p><p name="c682" id="c682" class="graf graf--p graf-after--p">Let’s talk about the different parts and roles within a BLE server (as example we use a Heart Rate Monitor) to get a general overview.</p><p name="aa14" id="aa14" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What is the purpose of a Heart Rate Monitor (HRM) ?</strong> The HRM has a sensor that detects the beating heart and the actual rate - usually this data is shown on a monitor or a remote device. The usage of Bluetooth is useful as it avoids any cables between the sensor and a remote device. As the amount and structure of the data is limited a connection using the <strong class="markup--strong markup--p-strong">Bluetooth Low Energy technology</strong> is the best choice.</p><p name="0733" id="0733" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What data should be exchanged between the server and the client ?</strong> The most important data is the heart rate, but there are some other information that should be available as well, here are some examples:</p><ul class="postList"><li name="9fe3" id="9fe3" class="graf graf--li graf-after--p">The heart rate measurement, taken from a sensor</li><li name="c16b" id="c16b" class="graf graf--li graf-after--li">the device manufacturer and model in use</li><li name="ecf3" id="ecf3" class="graf graf--li graf-after--li">the device’s serial number (think of a sports studio — is the data of my own or my neighbor’s device ?)</li><li name="318a" id="318a" class="graf graf--li graf-after--li">a timestamp of the measured heart rate</li><li name="7a66" id="7a66" class="graf graf--li graf-after--li">the battery status of a device (the original code does not offer this information, it will be added in one of the following parts).</li></ul><p name="a57e" id="a57e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">How is the BLE HRM device internally organized ?</strong> The device provides <strong class="markup--strong markup--p-strong">services</strong> that cover the above tasks, so it has a <strong class="markup--strong markup--p-strong">Device Information Service</strong> (provide information about the device like the name, model and serial number), a <strong class="markup--strong markup--p-strong">Heart Rate Service</strong> (provide the data on a one time or regular basis), a <strong class="markup--strong markup--p-strong">Current Time Service</strong> (date and time on the device) and a <strong class="markup--strong markup--p-strong">Battery Service</strong> (status of the internal battery). Additionally there are basic (generic) services called <strong class="markup--strong markup--p-strong">Generic Attribute</strong> and <strong class="markup--strong markup--p-strong">Generic Access</strong> available.</p><p name="0605" id="0605" class="graf graf--p graf-after--p">A service itself does not provide the data but a <strong class="markup--strong markup--p-strong">characteristic</strong> that is the „door“ to the data - either for reading the data from the the device (meant from the side of a client) or write data on the device. Each characteristic has <strong class="markup--strong markup--p-strong">properties</strong> who define the flow of data. Additionally there are <strong class="markup--strong markup--p-strong">permissions</strong> that define how to access or write the data and flags that are responsible for extra services, they are organized in <strong class="markup--strong markup--p-strong">Descriptors</strong>.</p><p name="7c56" id="7c56" class="graf graf--p graf-after--p">Each service and characteristic is identified by an <strong class="markup--strong markup--p-strong">Universally Unique Identifier (UUID)</strong> and some of them are defined by the Bluetooth SIG - a group that is responsible for standardization.</p><p name="28cc" id="28cc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How is a client connected to the server/device ?</strong> To get a connection to a server it is necessary that the server „offers“ his task(s), this is called <strong class="markup--strong markup--p-strong">advertising</strong>. A device usually only advertises it’s main service (here the Heart Rate Service). As we are talking about „Low Energy“ this advertising is done only when the server is in <strong class="markup--strong markup--p-strong">advertising mode</strong> - e.g. by pressing a button on the device. Now a client can search for this device and make a connection. When both parties agreed both partners are tied or bonded and the advertising mode ends.</p><p name="a728" id="a728" class="graf graf--p graf-after--p">Putting all together there are a lot of complex tasks and the named library will overtake most of them.</p><p name="663c" id="663c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How is code for the server organized ?</strong> From the layouts perspective there is a very sparing UI that just gives an information about the purpose of the app and there will be no interaction between the UI and the server.</p><figure name="731d" id="731d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*y9qNlqH3p9yHdg7s2oF81Q.png" data-width="500" data-height="297" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*y9qNlqH3p9yHdg7s2oF81Q.png"></figure><p name="96b5" id="96b5" class="graf graf--p graf-after--figure">Seeing the code, the <strong class="markup--strong markup--p-strong">MainActivity.java</strong> is responsible to grant the necessary runtime permissions to use Bluetooth LE and start the server itself.</p><p name="ea86" id="ea86" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">BluetoothServer.java</strong> is the place where all of the action takes place. As the Bluetooth api’s (Android system) are of a-synchronic nature there are callbacks that receive the results of any action regarding the services. The data itself comes and goes to dedicated service classes.</p><p name="59c2" id="59c2" class="graf graf--p graf-after--p">There is a <strong class="markup--strong markup--p-strong">Service interface</strong> that is between the BluetoothServer and each service class like the „HeartRateService“ - all of them extended from the BaseService-class.</p><p name="0371" id="0371" class="graf graf--p graf-after--p">I don’t explain each method of the server but the most important parts of the workflow:</p><ul class="postList"><li name="f522" id="f522" class="graf graf--li graf-after--p">startup of the server</li><li name="4056" id="4056" class="graf graf--li graf-after--li">connect the client with the server</li><li name="3830" id="3830" class="graf graf--li graf-after--li">get the services the server provides</li><li name="7db0" id="7db0" class="graf graf--li graf-after--li">get data from the server</li><li name="bdb8" id="bdb8" class="graf graf--li graf-after--li">arrange subscriptions for some data</li><li name="d937" id="d937" class="graf graf--li graf-after--li">write data from the client to the server (available in a following part)</li></ul><ol class="postList"><li name="c755" id="c755" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">startup of the server (BluetoothServer.java)</strong></li></ol><p name="aef6" id="aef6" class="graf graf--p graf-after--li">The server get’s his name from the smartphone, all services are instantiated and the advertising starts with the main purpose of the server, the HeartRateService is starting the advertisement.</p><pre name="1365" id="1365" class="graf graf--pre graf-after--p">bluetoothAdapter.setName(Build.<em class="markup--em markup--pre-em">MODEL</em>);</pre><pre name="55bc" id="55bc" class="graf graf--pre graf-after--pre">DeviceInformationService deviceInformationService = new DeviceInformationService(peripheralManager);</pre><pre name="0ca3" id="0ca3" class="graf graf--pre graf-after--pre">CurrentTimeService currentTimeService = new CurrentTimeService(peripheralManager);</pre><pre name="69ef" id="69ef" class="graf graf--pre graf-after--pre">HeartRateService heartRateService = new HeartRateService(peripheralManager);</pre><pre name="ae68" id="ae68" class="graf graf--pre graf-after--pre">startAdvertising(heartRateService.getService().getUuid());</pre><p name="7f3a" id="7f3a" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. connect the client with the server</strong></p><p name="7bab" id="7bab" class="graf graf--p graf-after--p">As you can see there is minimal code necessary to get a connection to the server, all actions are handled within the library.</p><pre name="dbc5" id="dbc5" class="graf graf--pre graf-after--p">BluetoothPeripheralManagerCallback</pre><pre name="850c" id="850c" class="graf graf--pre graf-after--pre">@Override<br>public void onCentralConnected(@NotNull BluetoothCentral central) {<br>    for (Service serviceImplementation : serviceImplementations.values()) {<br>        serviceImplementation.onCentralConnected(central);<br>    }<br>}</pre><p name="d17d" id="d17d" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. get the services the server provides</strong></p><p name="c407" id="c407" class="graf graf--p graf-after--p">This part is done without additional code from us.</p><p name="a05f" id="a05f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. get data from the server</strong></p><p name="a33a" id="a33a" class="graf graf--p graf-after--p">At the time the client (also called „central“) demands data from the server we need to follow the next callback:</p><pre name="49cd" id="49cd" class="graf graf--pre graf-after--p">BluetoothPeripheralManagerCallback</pre><pre name="adde" id="adde" class="graf graf--pre graf-after--pre">@Override<br>public @NotNull ReadResponse onCharacteristicRead(@NotNull BluetoothCentral central, @NotNull BluetoothGattCharacteristic characteristic) {<br>    Service serviceImplementation = serviceImplementations.get(characteristic.getService());<br>    if (serviceImplementation != null) {<br>        return serviceImplementation.onCharacteristicRead(central, characteristic);<br>    }<br>    return super.onCharacteristicRead(central, characteristic);<br>}</pre><p name="2c81" id="2c81" class="graf graf--p graf-after--pre">The request to read some data includes the <strong class="markup--strong markup--p-strong">BluetoothGattCharacteristic</strong> that is forwarded through the Service-interface to a class that provides an interaction for the specific service and characteristic. In our case the client demands for a service-UUID „0000180D-0000–1000–8000–00805f9b34fb“ and a characteristic-UUID „00002A37–0000–1000–8000–00805f9b34fb“, both are defined in the HeartRateService.java-class:</p><pre name="13bf" id="13bf" class="graf graf--pre graf-after--p">private static final UUID <em class="markup--em markup--pre-em">HEART_RATE_SERVICE_UUID </em>= UUID.<em class="markup--em markup--pre-em">fromString</em>(“0000180D-0000–1000–8000–00805f9b34fb”);</pre><pre name="95d5" id="95d5" class="graf graf--pre graf-after--pre">private static final UUID <em class="markup--em markup--pre-em">HEART_RATE_MEASUREMENT_CHARACTERISTIC_UUID </em>= UUID.<em class="markup--em markup--pre-em">fromString</em>(“00002A37–0000–1000–8000–00805f9b34fb”);</pre><p name="89aa" id="89aa" class="graf graf--p graf-after--pre">Here we do find a method in that class that provides the requested data — in our case it is the fixed value „0x00, 0x40“. Without going deeper at the moment, the heart rate value is represented in „little endian“ byte order and in decimals the value is „64“ (beats per minute). Check the data with a client app (e.g. with „nRF connect“).</p><pre name="8584" id="8584" class="graf graf--pre graf-after--p">HeartRateService</pre><pre name="2c2f" id="2c2f" class="graf graf--pre graf-after--pre">@Override<br>public ReadResponse onCharacteristicRead(@NotNull BluetoothCentral central, @NotNull BluetoothGattCharacteristic characteristic) {<br>    if (characteristic.getUuid().equals(<em class="markup--em markup--pre-em">HEART_RATE_MEASUREMENT_CHARACTERISTIC_UUID</em>)) {<br>        return new ReadResponse(GattStatus.<em class="markup--em markup--pre-em">SUCCESS</em>, new byte[]{0x00, 0x40});<br>    }<br>    return super.onCharacteristicRead(central, characteristic);<br>}</pre><p name="9e9b" id="9e9b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. arrange subscriptions for some data</strong></p><p name="7dc1" id="7dc1" class="graf graf--p graf-after--p">Usually we do want to get the data (here the heart rate) not only once but continuously, at the best each time the value changes. For that reasons we could a timer that periodically requests the data but a better option is to use a <strong class="markup--strong markup--p-strong">notification</strong>. If a notification is set on the server for a specific characteristic the server will provide new data as internally set up. For our server a notification is available with the HeartRateService by adding the descriptor:</p><pre name="5093" id="5093" class="graf graf--pre graf-after--p">public HeartRateService(@NotNull BluetoothPeripheralManager peripheralManager) {<br>    super(peripheralManager);<br>    service.addCharacteristic(measurement);<br>    measurement.addDescriptor(getClientCharacteristicConfigurationDescriptor());<br>}</pre><p name="ad48" id="ad48" class="graf graf--p graf-after--pre">If the client is requesting such a notification the service class is informed by the BluetoothServer-class through the Service-interface to the HeartRateService-class:</p><pre name="51f4" id="51f4" class="graf graf--pre graf-after--p">@Override<br>public void onNotifyingEnabled(@NotNull BluetoothCentral central, @NotNull BluetoothGattCharacteristic characteristic) {<br>    if (characteristic.getUuid().equals(<em class="markup--em markup--pre-em">HEART_RATE_MEASUREMENT_CHARACTERISTIC_UUID</em>)) {<br>        notifyHeartRate();<br>    }<br>}</pre><p name="ba9d" id="ba9d" class="graf graf--p graf-after--pre">The notifyHeartRate-method is a simulated sensor measurement in our server and provides a new value every second:</p><pre name="c52a" id="c52a" class="graf graf--pre graf-after--p">private void notifyHeartRate() {<br>    currentHR += (int) ((Math.<em class="markup--em markup--pre-em">random</em>() * 10) - 5);<br>    if (currentHR &gt; 120) currentHR = 100;<br>    final byte[] value = new byte[]{0x00, (byte) currentHR};<br>    notifyCharacteristicChanged(value, measurement);<br>    handler.postDelayed(notifyRunnable, 1000);<br>    Timber.<em class="markup--em markup--pre-em">i</em>(&quot;new hr: %d&quot;, currentHR);<br>}</pre><p name="a6b2" id="a6b2" class="graf graf--p graf-after--pre">The method is informing the BluetoothServer and the value is send to the client:</p><pre name="265b" id="265b" class="graf graf--pre graf-after--p">BluetoothServer</pre><pre name="395d" id="395d" class="graf graf--pre graf-after--pre">@Override<br>public void onNotificationSent(@NotNull BluetoothCentral central, byte[] value, @NotNull BluetoothGattCharacteristic characteristic, @NotNull GattStatus status) {<br>    Service serviceImplementation = serviceImplementations.get(characteristic.getService());<br>    if (serviceImplementation != null) {<br>        serviceImplementation.onNotificationSent(central, value, characteristic, status);<br>    }<br>}</pre><p name="3b0a" id="3b0a" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. write data from the client to the server (available in a following part)</strong></p><p name="f0c1" id="f0c1" class="graf graf--p graf-after--p">This app does not cover the writing of data from the client to the server, but the method to receive the data in BluetoothServer is this callback:</p><pre name="d330" id="d330" class="graf graf--pre graf-after--p">BluetoothServer</pre><pre name="97c1" id="97c1" class="graf graf--pre graf-after--pre">@Override<br>public @NotNull GattStatus onCharacteristicWrite(@NotNull BluetoothCentral central, @NotNull BluetoothGattCharacteristic characteristic, @NotNull byte[] value) {<br>    Service serviceImplementation = serviceImplementations.get(characteristic.getService());<br>    if (serviceImplementation != null) {<br>        return serviceImplementation.onCharacteristicWrite(central, characteristic, value);<br>    }<br>    return GattStatus.<em class="markup--em markup--pre-em">REQUEST_NOT_SUPPORTED</em>;<br>}</pre><p name="ea6d" id="ea6d" class="graf graf--p graf-after--pre">followed by a confirmation send from the server to the client:</p><pre name="84ac" id="84ac" class="graf graf--pre graf-after--p">BluetoothServer</pre><pre name="c6ba" id="c6ba" class="graf graf--pre graf-after--pre">@Override<br>public void onCharacteristicWriteCompleted(@NonNull BluetoothCentral central, @NonNull BluetoothGattCharacteristic characteristic, @NonNull byte[] value) {<br>    Service serviceImplementation = serviceImplementations.get(characteristic.getService());<br>    if (serviceImplementation != null) {<br>        serviceImplementation.onCharacteristicWriteCompleted(central, characteristic, value);<br>    }<br>}</pre><p name="f47e" id="f47e" class="graf graf--p graf-after--pre">How to interact with the server ? As mentioned in the beginning I recommend the <strong class="markup--strong markup--p-strong">nRF Connect app</strong> to get an easy access to all services and characteristics this server offers. Another option is the <strong class="markup--strong markup--p-strong">BleClientBlessedOriginal</strong> app that is described in a separately article.</p><p name="a9f1" id="a9f1" class="graf graf--p graf-after--p">The complete source code for the BleServerBlessedOriginal is available on my GitHub repository: <a href="https://github.com/AndroidCrypto/BleServerBlessedOriginal" data-href="https://github.com/AndroidCrypto/BleServerBlessedOriginal" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/AndroidCrypto/BleServerBlessedOriginal</a></p><p name="edb3" id="edb3" class="graf graf--p graf-after--p graf--trailing">Just follow me to get informed as soon the next part is published.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@androidcrypto" class="p-author h-card">AndroidCrypto</a> on <a href="https://medium.com/p/dbf8dadd75b5"><time class="dt-published" datetime="2022-10-26T14:36:41.203Z">October 26, 2022</time></a>.</p><p><a href="https://medium.com/@androidcrypto/setup-your-own-android-bluetooth-low-energy-server-part-1-dbf8dadd75b5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 27, 2022.</p></footer></article></body></html>