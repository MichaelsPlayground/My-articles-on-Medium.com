<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Setup a Android Bluetooth Low Energy client part 1</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Setup a Android Bluetooth Low Energy client part 1</h1>
</header>
<section data-field="subtitle" class="p-summary">
This article series is about an app that act as a Bluetooth Low Energy (BLE) client but not about the basic technology itself. If you need…
</section>
<section data-field="body" class="e-content">
<section name="6905" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="21dc" id="21dc" class="graf graf--h3 graf--leading graf--title">Setup a Android Bluetooth Low Energy client part 1</h3><p name="4e50" id="4e50" class="graf graf--p graf-after--h3">This article series is about an app that act as a Bluetooth Low Energy (BLE) client but not about the basic technology itself. If you need more information and a deep look into Bluetooth Low Energy I recommend this article: “The Ultimate Guide to Android Bluetooth Low Energy“ (<a href="https://punchthrough.com/android-ble-guide/" data-href="https://punchthrough.com/android-ble-guide/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://punchthrough.com/android-ble-guide/</a>).</p><p name="86ea" id="86ea" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Why do we need a self programmed BLE client ?</strong> Most devices like a Heart Rate or Temperature measurement come with their own’s app. But sometimes you would like to combine two devices in one app or the “old” app of the manufaturer is no longer available for (new) devices. In that case it is useful to give those devices a second chance with a self programmed client app.</p><p name="d00a" id="d00a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What do I need to follow the article ?</strong> You should use a modern Android Studio system (as of year 2022) and have 2 Android smartphones (SDK min 21) with Bluetooth capabilities to run the server on one and the client on the other smartphone. I’m using Java to run my server but the code can easily converted to Kotlin with Android Studio. To get a professional view on the server and the services provided I recommend that you install a client app on your second device, my first choice is „nRF Connect for Mobile“ and it is available in the PlayStore: „<a href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=de&amp;gl=US" data-href="https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=de&amp;gl=US" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&amp;hl=de&amp;gl=US</a>&quot;.</p><p name="a659" id="a659" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How do we start ?</strong> On the official Android Developer sites (<a href="https://developer.android.com/guide/topics/connectivity/bluetooth/ble-overview" data-href="https://developer.android.com/guide/topics/connectivity/bluetooth/ble-overview" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://developer.android.com/guide/topics/connectivity/bluetooth/ble-overview</a>) and the connectivity-samples on GitHub (<a href="https://github.com/android/connectivity-samples" data-href="https://github.com/android/connectivity-samples" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/android/connectivity-samples</a>) you get the basics but for me it was hard to get them to run.</p><p name="96d0" id="96d0" class="graf graf--p graf-after--p">I was very happy to find the library <strong class="markup--strong markup--p-strong">blessed-android</strong> (https://github.com/weliem/blessed-android) from <strong class="markup--strong markup--p-strong">Martijn van Welie</strong> that has an actual and running example for a BLE client and server. This article series is based on the library that’s main purpose is to develop a BLE client.</p><p name="dc6b" id="dc6b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Why do I use a library for BLE and don’t use the pure BLE apis ?</strong> There are many reasons but the most important point is that the blessed-android library supports <strong class="markup--strong markup--p-strong">queueing of commands</strong>. As the BLE apis run a-synchronic you have to wait until a read or write command is delivered before submitting the next command. This can lead to an unexpected behavior and errors — better use the recommend library.</p><p name="9bb3" id="9bb3" class="graf graf--p graf-after--p">There is a companion article series that covers the <strong class="markup--strong markup--p-strong">setup of an own Android Bluetooth Low Energy Server: </strong><a href="https://medium.com/@androidcrypto/connect-the-android-nrf-connect-mobile-app-with-a-bluetooth-low-energy-device-8ba900d70286" data-href="https://medium.com/@androidcrypto/connect-the-android-nrf-connect-mobile-app-with-a-bluetooth-low-energy-device-8ba900d70286" class="markup--anchor markup--p-anchor" target="_blank">https://medium.com/@androidcrypto/connect-the-android-nrf-connect-mobile-app-with-a-bluetooth-low-energy-device-8ba900d70286</a>.</p><p name="12b2" id="12b2" class="graf graf--p graf-after--p">Let’s talk about the different parts and roles within a BLE client (as example we use a Heart Rate Monitor device) to get a general overview.</p><p name="0bea" id="0bea" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What is the purpose of a Heart Rate Monitor (HRM) ?</strong> The HRM has a sensor that detects the beating heart and the actual rate - usually this data is shown on a monitor or a remote device. The usage of Bluetooth is useful as it avoids any cables between the sensor and a remote device. As the amount and structure of the data is limited a connection using the <strong class="markup--strong markup--p-strong">Bluetooth Low Energy technology</strong> is the best choice.</p><p name="0733" id="0733" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">What data should be exchanged between the server and the client ?</strong> The most important data is the heart rate, but there are some other information that should be available as well, here are some examples:</p><ul class="postList"><li name="9fe3" id="9fe3" class="graf graf--li graf-after--p">The heart rate measurement, taken from a sensor</li><li name="c16b" id="c16b" class="graf graf--li graf-after--li">the device manufacturer and model in use</li><li name="ecf3" id="ecf3" class="graf graf--li graf-after--li">the device’s serial number (think of a sports studio — is the data of my own or my neighbor’s device ?)</li><li name="318a" id="318a" class="graf graf--li graf-after--li">a timestamp of the measured heart rate</li><li name="7a66" id="7a66" class="graf graf--li graf-after--li">the battery status of a device</li></ul><p name="a57e" id="a57e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">How is the BLE HRM device internally organized ?</strong> The device provides <strong class="markup--strong markup--p-strong">services</strong> that cover the above tasks, so it has a <strong class="markup--strong markup--p-strong">Device Information Service</strong> (provide information about the device like the name, model and serial number), a <strong class="markup--strong markup--p-strong">Heart Rate Service</strong> (provide the data on a one time or regular basis), a <strong class="markup--strong markup--p-strong">Current Time Service</strong> (date and time on the device) and a <strong class="markup--strong markup--p-strong">Battery Service</strong> (status of the internal battery). Additionally there are basic (generic) services called <strong class="markup--strong markup--p-strong">Generic Attribute</strong> and <strong class="markup--strong markup--p-strong">Generic Access</strong> available.</p><p name="0605" id="0605" class="graf graf--p graf-after--p">A service itself does not provide the data but a <strong class="markup--strong markup--p-strong">characteristic</strong> that is the „door“ to the data - either for reading the data from the the device (meant from the side of a client) or write data on the device. Each characteristic has <strong class="markup--strong markup--p-strong">properties</strong> who define the flow of data. Additionally there are <strong class="markup--strong markup--p-strong">permissions</strong> that define how to access or write the data and flags that are responsible for extra services, they are organized in <strong class="markup--strong markup--p-strong">Descriptors</strong>.</p><p name="7c56" id="7c56" class="graf graf--p graf-after--p">Each service and characteristic is identified by an <strong class="markup--strong markup--p-strong">Universally Unique Identifier (UUID)</strong> and some of them are defined by the Bluetooth SIG - a group that is responsible for standardization.</p><p name="28cc" id="28cc" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How is a client connected to the server/device ?</strong> To get a connection to a server it is necessary that the server „offers“ his task(s), this is called <strong class="markup--strong markup--p-strong">advertising</strong>. A device usually only advertises it’s main service (here the Heart Rate Service). As we are talking about „Low Energy“ this advertising is done only when the server is in <strong class="markup--strong markup--p-strong">advertising mode</strong> - e.g. by pressing a button on the device. Now the client can search for this device and make a connection. When both parties agreed both partners are tied or bonded and the advertising mode ends.</p><p name="a728" id="a728" class="graf graf--p graf-after--p">Putting all together there are a lot of complex tasks and the named library will overtake most of them.</p><p name="663c" id="663c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">How is code for the server organized ?</strong> From the layouts perspective there is a very sparing UI that just gives an information about the purpose of the app and a measured value when the app is connected to a fitting server.</p><figure name="fe80" id="fe80" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*yO1SWfx4KMtQvf80gXQHkw.png" data-width="500" data-height="420" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*yO1SWfx4KMtQvf80gXQHkw.png"></figure><p name="4d2e" id="4d2e" class="graf graf--p graf-after--figure">Seeing the code, the <strong class="markup--strong markup--p-strong">MainActivity.java</strong> is responsible to grant the necessary runtime permissions to use Bluetooth LE, start the client in the BluetoothHandler-class and receive some data (a measured value) from the BluetoothHandler class.</p><p name="c6bb" id="c6bb" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">BluetoothHandler.java</strong> is the place where all of the action takes place. As the Bluetooth api’s (Android system) are of a-synchronic nature there are callbacks that receive the results of any action regarding the services. The data itself comes and goes to dedicated service classes (e.g. HeartRateMeasurement.java).</p><p name="a2c8" id="a2c8" class="graf graf--p graf-after--p">I don’t explain each method of the client but the most important parts of the workflow:</p><ul class="postList"><li name="f522" id="f522" class="graf graf--li graf-after--p">startup of the client</li><li name="abdc" id="abdc" class="graf graf--li graf-after--li">scan for Bluetooth Low Energy devices that offer a service that our client is searching for (e.g. a Heart Rate Measurement Service)</li><li name="4056" id="4056" class="graf graf--li graf-after--li">connect the client with the server</li><li name="3830" id="3830" class="graf graf--li graf-after--li">get the services the server provides</li><li name="7db0" id="7db0" class="graf graf--li graf-after--li">get data from the server and deliver the received data to the MainActivity (= UI)</li><li name="bdb8" id="bdb8" class="graf graf--li graf-after--li">arrange subscriptions for some data</li><li name="d937" id="d937" class="graf graf--li graf-after--li">write data from the client to the server (available in a following part)</li></ul><ol class="postList"><li name="8bd1" id="8bd1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">startup of the client (MainActivity.java and BluetoothHandler.java)</strong></li></ol><p name="d1c9" id="d1c9" class="graf graf--p graf-after--li">The client is started by getting the instance of the BluetoothHandler-class</p><pre name="178b" id="178b" class="graf graf--pre graf-after--p">private void initBluetoothHandler()<br>{<br>    BluetoothHandler.<em class="markup--em markup--pre-em">getInstance</em>(getApplicationContext());<br>}</pre><p name="62a6" id="62a6" class="graf graf--p graf-after--pre">In the called BluetoothHandler-class the client starts by initiating the callback and directly starts a scan for devices:</p><pre name="80e4" id="80e4" class="graf graf--pre graf-after--p">private BluetoothHandler(Context context) {<br>    this.context = context;<br>    ... <br>    <em class="markup--em markup--pre-em">// Create BluetoothCentral<br>    </em>central = new BluetoothCentralManager(context, bluetoothCentralManagerCallback, new Handler());<br><br>    <em class="markup--em markup--pre-em">// Scan for peripherals with a certain service UUIDs<br>    </em>central.startPairingPopupHack();<br>    startScan();<br>}</pre><p name="92a7" id="92a7" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">2. scan for Bluetooth Low Energy devices (BluetoothHandler.java)</strong></p><p name="148d" id="148d" class="graf graf--p graf-after--p">The scanning is started after the client has setup and the client searches for services like the Heart Rate Service or a Temperature Service. As each service has it’s own data structures it is import to search only for those devices that the client is been able to process:</p><pre name="5b7d" id="5b7d" class="graf graf--pre graf-after--p">private void startScan() {<br>    handler.postDelayed(new Runnable() {<br>        @Override<br>        public void run() {<br>            <em class="markup--em markup--pre-em">// ### add HRS = HeartRate service to scan UUIDs<br>            </em>central.scanForPeripheralsWithServices(new UUID[]{<em class="markup--em markup--pre-em">HEART_RATE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">BLOOD_PRESSURE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">HEALTH_THERMOMETER_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">PULSE_OXIMETER_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">WEIGHT_SCALE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">GLUCOSE_SERVICE_UUID</em>});<em class="markup--em markup--pre-em"><br>        </em>}<br>    },1000);<br>}</pre><p name="401c" id="401c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">3. connect the client with the server (BluetoothHandler.java)</strong></p><p name="2aaa" id="2aaa" class="graf graf--p graf-after--p">The library overtakes the most work for us a discovered server (or “peripheral”) will lead in a connect process. The code shows how to check for special devices that need a deviant behavior:</p><pre name="7fea" id="7fea" class="graf graf--pre graf-after--p">BluetoothCentralManagerCallback</pre><pre name="2198" id="2198" class="graf graf--pre graf-after--pre">@Override<br>public void onDiscoveredPeripheral(@NotNull BluetoothPeripheral peripheral, @NotNull ScanResult scanResult) {<br>    Timber.<em class="markup--em markup--pre-em">i</em>(&quot;Found peripheral &#39;%s&#39;&quot;, peripheral.getName());<br>    central.stopScan();<br><br>    if (peripheral.getName().contains(&quot;Contour&quot;) &amp;&amp; peripheral.getBondState() == BondState.<em class="markup--em markup--pre-em">NONE</em>) {<br>        <em class="markup--em markup--pre-em">// Create a bond immediately to avoid double pairing popups<br>        </em>central.createBond(peripheral, peripheralCallback);<br>    } else {<br>        central.connectPeripheral(peripheral, peripheralCallback);<br>    }<br>}</pre><p name="7910" id="7910" class="graf graf--p graf-after--pre">The connection takes place and another callback is starting:</p><pre name="c052" id="c052" class="graf graf--pre graf-after--p">BluetoothCentralManagerCallback</pre><pre name="b10f" id="b10f" class="graf graf--pre graf-after--pre">@Override<br>public void onConnectedPeripheral(@NotNull BluetoothPeripheral peripheral) {<br>    Timber.<em class="markup--em markup--pre-em">i</em>(&quot;connected to &#39;%s&#39;&quot;, peripheral.getName());<br>}</pre><p name="ca73" id="ca73" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">4. get the services the server provides (BluetoothHandler.java)</strong></p><p name="4a82" id="4a82" class="graf graf--p graf-after--p">When the client receives the services it immediately starts its processing on different services. If there is a Device Information Service running it demands for the manufacturer name and the model number of the server. Secondly it checks for a Current Time Service and — if the data is writable — it sends the actual time to the server. Thirdly, if there are notifications available it enables them to get more than one measured value (“one time”) but a contious flow of data.</p><pre name="1c3c" id="1c3c" class="graf graf--pre graf-after--p">BluetoothPeripheralCallback</pre><pre name="98d0" id="98d0" class="graf graf--pre graf-after--pre">private final BluetoothPeripheralCallback peripheralCallback = new BluetoothPeripheralCallback() {<br>    @Override<br>    public void onServicesDiscovered(@NotNull BluetoothPeripheral peripheral) {<br>        <em class="markup--em markup--pre-em">// Request a higher MTU, iOS always asks for 185<br>        </em>peripheral.requestMtu(185);<br>        <em class="markup--em markup--pre-em">// Request a new connection priority<br>        </em>peripheral.requestConnectionPriority(ConnectionPriority.<em class="markup--em markup--pre-em">HIGH</em>);<em class="markup--em markup--pre-em"><br>        // Read manufacturer and model number from the Device Information Service        </em>peripheral.readCharacteristic(<em class="markup--em markup--pre-em">DEVICE_INFORMATION_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">MANUFACTURER_NAME_CHARACTERISTIC_UUID</em>);        peripheral.readCharacteristic(<em class="markup--em markup--pre-em">DEVICE_INFORMATION_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">MODEL_NUMBER_CHARACTERISTIC_UUID</em>);</pre><pre name="d08d" id="d08d" class="graf graf--pre graf-after--pre">        peripheral.readPhy();<br>        <em class="markup--em markup--pre-em">// Turn on notifications for Current Time Service and write it if possible<br>        </em>BluetoothGattCharacteristic currentTimeCharacteristic = peripheral.getCharacteristic(<em class="markup--em markup--pre-em">CURRENT_TIME_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">CURRENT_TIME_CHARACTERISTIC_UUID</em>);<br>        if (currentTimeCharacteristic != null) {<br>            peripheral.setNotify(currentTimeCharacteristic, true);<br><br>            <em class="markup--em markup--pre-em">// If it has the write property we write the current time<br>            </em>if ((currentTimeCharacteristic.getProperties() &amp; <em class="markup--em markup--pre-em">PROPERTY_WRITE</em>) &gt; 0) {<br>                <em class="markup--em markup--pre-em">// Write the current time unless it is an Omron device<br>                </em>if (!isOmronBPM(peripheral.getName())) {<br>                    BluetoothBytesParser parser = new BluetoothBytesParser();<br>                    parser.setCurrentTime(Calendar.<em class="markup--em markup--pre-em">getInstance</em>());<br>                    peripheral.writeCharacteristic(currentTimeCharacteristic, parser.getValue(), WriteType.<em class="markup--em markup--pre-em">WITH_RESPONSE</em>);<br>                }<br>            }<br>        }<br><br>        <em class="markup--em markup--pre-em">// Try to turn on notifications for other characteristics<br>        </em>peripheral.readCharacteristic(<em class="markup--em markup--pre-em">BATTERY_LEVEL_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">BATTERY_LEVEL_CHARACTERISTIC_UUID</em>);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">BLOOD_PRESSURE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">BLOOD_PRESSURE_MEASUREMENT_CHARACTERISTIC_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">HEALTH_THERMOMETER_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">TEMPERATURE_MEASUREMENT_CHARACTERISTIC_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">HEART_RATE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">HEART_RATE_MEASUREMENT_CHARACTERISTIC_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">PULSE_OXIMETER_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">PULSE_OXIMETER_CONTINUOUS_MEASUREMENT_CHAR_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">PULSE_OXIMETER_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">PULSE_OXIMETER_SPOT_MEASUREMENT_CHAR_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">WEIGHT_SCALE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">WEIGHT_SCALE_MEASUREMENT_CHAR_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">GLUCOSE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">GLUCOSE_MEASUREMENT_CHARACTERISTIC_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">GLUCOSE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">GLUCOSE_MEASUREMENT_CONTEXT_CHARACTERISTIC_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">GLUCOSE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">GLUCOSE_RECORD_ACCESS_POINT_CHARACTERISTIC_UUID</em>, true);<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">CONTOUR_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">CONTOUR_CLOCK</em>, true);<br>    }</pre><p name="a209" id="a209" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">5. get data from the server (BluetoothHandler.java)</strong></p><p name="511b" id="511b" class="graf graf--p graf-after--p">If any measurement on the server changes there will be a new value provided by the server and the value changes, so the callback for “onCharacteristicUpdate” is called. The client is checking for each specific UUID and decides what to do with the data received. After the data is analyzed by the UUID-specific class it gets delivered to the MainActivity with an Broadcast-Intent.</p><pre name="f705" id="f705" class="graf graf--pre graf-after--p">@Override<br>public void onCharacteristicUpdate(@NotNull BluetoothPeripheral peripheral, @NotNull byte[] value, @NotNull BluetoothGattCharacteristic characteristic, @NotNull GattStatus status) {<br>    if (status != GattStatus.<em class="markup--em markup--pre-em">SUCCESS</em>) return;<br><br>    UUID characteristicUUID = characteristic.getUuid();<br>    BluetoothBytesParser parser = new BluetoothBytesParser(value);<br><br>    if (characteristicUUID.equals(<em class="markup--em markup--pre-em">BLOOD_PRESSURE_MEASUREMENT_CHARACTERISTIC_UUID</em>)) {<br>        BloodPressureMeasurement measurement = new BloodPressureMeasurement(value);<br>        Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_BLOODPRESSURE</em>);<br>        intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_BLOODPRESSURE_EXTRA</em>, measurement);<br>        sendMeasurement(intent, peripheral);<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">TEMPERATURE_MEASUREMENT_CHARACTERISTIC_UUID</em>)) {<br>        TemperatureMeasurement measurement = new TemperatureMeasurement(value);<br>        Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_TEMPERATURE</em>);<br>        intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_TEMPERATURE_EXTRA</em>, measurement);<br>        sendMeasurement(intent, peripheral);<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">HEART_RATE_MEASUREMENT_CHARACTERISTIC_UUID</em>)) {<br>        HeartRateMeasurement measurement = new HeartRateMeasurement(value);<br>        Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE</em>);<br>        intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE_EXTRA</em>, measurement);<br>        sendMeasurement(intent, peripheral);<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">PULSE_OXIMETER_CONTINUOUS_MEASUREMENT_CHAR_UUID</em>)) {<br>        PulseOximeterContinuousMeasurement measurement = new PulseOximeterContinuousMeasurement(value);<br>        if (measurement.getSpO2() &lt;= 100 &amp;&amp; measurement.getPulseRate() &lt;= 220) {<br>            Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_PULSE_OX</em>);<br>            intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_PULSE_OX_EXTRA_CONTINUOUS</em>, measurement);<br>            sendMeasurement(intent, peripheral);<br>        }<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">PULSE_OXIMETER_SPOT_MEASUREMENT_CHAR_UUID</em>)) {<br>        PulseOximeterSpotMeasurement measurement = new PulseOximeterSpotMeasurement(value);<br>        Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_PULSE_OX</em>);<br>        intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_PULSE_OX_EXTRA_SPOT</em>, measurement);<br>        sendMeasurement(intent, peripheral);<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">WEIGHT_SCALE_MEASUREMENT_CHAR_UUID</em>)) {<br>        WeightMeasurement measurement = new WeightMeasurement(value);<br>        Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_WEIGHT</em>);<br>        intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_WEIGHT_EXTRA</em>, measurement);<br>        sendMeasurement(intent, peripheral);<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    } else if (characteristicUUID.equals((<em class="markup--em markup--pre-em">GLUCOSE_MEASUREMENT_CHARACTERISTIC_UUID</em>))) {<br>        GlucoseMeasurement measurement = new GlucoseMeasurement(value);<br>        Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_GLUCOSE</em>);<br>        intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_GLUCOSE_EXTRA</em>, measurement);<br>        sendMeasurement(intent, peripheral);<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">CURRENT_TIME_CHARACTERISTIC_UUID</em>)) {<br>        Date currentTime = parser.getDateTime();<br>        <em class="markup--em markup--pre-em">// ### added some line to show the received Current Time from server<br><br><br>        </em>Timber.<em class="markup--em markup--pre-em">i</em>(&quot;Received device time: %s&quot;, currentTime);<br><br>        <em class="markup--em markup--pre-em">// Deal with Omron devices where we can only write currentTime under specific conditions<br>        </em>if (isOmronBPM(peripheral.getName())) {<br>            BluetoothGattCharacteristic bloodpressureMeasurement = peripheral.getCharacteristic(<em class="markup--em markup--pre-em">BLOOD_PRESSURE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">BLOOD_PRESSURE_MEASUREMENT_CHARACTERISTIC_UUID</em>);<br>            if (bloodpressureMeasurement == null) return;<br><br>            boolean isNotifying = peripheral.isNotifying(bloodpressureMeasurement);<br>            if (isNotifying) currentTimeCounter++;<br><br>            <em class="markup--em markup--pre-em">// We can set device time for Omron devices only if it is the first notification and currentTime is more than 10 min from now<br>            </em>long interval = <em class="markup--em markup--pre-em">abs</em>(Calendar.<em class="markup--em markup--pre-em">getInstance</em>().getTimeInMillis() - currentTime.getTime());<br>            if (currentTimeCounter == 1 &amp;&amp; interval &gt; 10 * 60 * 1000) {<br>                parser.setCurrentTime(Calendar.<em class="markup--em markup--pre-em">getInstance</em>());<br>                peripheral.writeCharacteristic(characteristic, parser.getValue(), WriteType.<em class="markup--em markup--pre-em">WITH_RESPONSE</em>);<br>            }<br>        }<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">BATTERY_LEVEL_CHARACTERISTIC_UUID</em>)) {<br>        int batteryLevel = parser.getIntValue(<em class="markup--em markup--pre-em">FORMAT_UINT8</em>);<br>        Timber.<em class="markup--em markup--pre-em">i</em>(&quot;Received battery level %d%%&quot;, batteryLevel);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">MANUFACTURER_NAME_CHARACTERISTIC_UUID</em>)) {<br>        String manufacturer = parser.getStringValue(0);<br>        Timber.<em class="markup--em markup--pre-em">i</em>(&quot;Received manufacturer: %s&quot;, manufacturer);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">MODEL_NUMBER_CHARACTERISTIC_UUID</em>)) {<br>        String modelNumber = parser.getStringValue(0);<br>        Timber.<em class="markup--em markup--pre-em">i</em>(&quot;Received modelnumber: %s&quot;, modelNumber);<br>    } else if (characteristicUUID.equals(<em class="markup--em markup--pre-em">PNP_ID_CHARACTERISTIC_UUID</em>)) {<br>        String modelNumber = parser.getStringValue(0);<br>        Timber.<em class="markup--em markup--pre-em">i</em>(&quot;Received pnp: %s&quot;, modelNumber);<br>    }<br>}</pre><p name="ded0" id="ded0" class="graf graf--p graf-after--pre">This is the workflow in detail for the Heart Rate Service:</p><pre name="7478" id="7478" class="graf graf--pre graf-after--p">if  characteristicUUID.equals(<em class="markup--em markup--pre-em">HEART_RATE_MEASUREMENT_CHARACTERISTIC_UUID</em>)) {<br>        HeartRateMeasurement measurement = new HeartRateMeasurement(value);<br>        Intent intent = new Intent(<em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE</em>);<br>        intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE_EXTRA</em>, measurement);<br>        sendMeasurement(intent, peripheral);<br>        Timber.<em class="markup--em markup--pre-em">d</em>(&quot;%s&quot;, measurement);<br>    }</pre><p name="16e5" id="16e5" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">step 1:</strong> the value is proceeded to the HeartRateMeasurement-class</p><p name="6c6f" id="6c6f" class="graf graf--p graf-after--p">A BluetoothByteParser is used to analyze the flags and the following value and returns the pulse:</p><pre name="6668" id="6668" class="graf graf--pre graf-after--p">HeartRateMeasurement.java</pre><pre name="62f1" id="62f1" class="graf graf--pre graf-after--pre">public HeartRateMeasurement(byte[] value) {<br>    BluetoothBytesParser parser = new BluetoothBytesParser(value);<br><br>    <em class="markup--em markup--pre-em">// Parse the flags<br>    </em>int flags = parser.getIntValue(<em class="markup--em markup--pre-em">FORMAT_UINT8</em>);<br>    final int unit = flags &amp; 0x01;<br>    final int sensorContactStatus = (flags &amp; 0x06) &gt;&gt; 1;<br>    final boolean energyExpenditurePresent = (flags &amp; 0x08) &gt; 0;<br>    final boolean rrIntervalPresent = (flags &amp; 0x10) &gt; 0;<br><br>    <em class="markup--em markup--pre-em">// Parse heart rate<br>    </em>this.pulse = (unit == 0) ? parser.getIntValue(<em class="markup--em markup--pre-em">FORMAT_UINT8</em>) : parser.getIntValue(<em class="markup--em markup--pre-em">FORMAT_UINT16</em>);<br>}</pre><p name="d08b" id="d08b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">step 2</strong>:</p><p name="aa3a" id="aa3a" class="graf graf--p graf-after--p">We define two constants for the specific measurement and its value and use them in the intent:</p><pre name="5b1d" id="5b1d" class="graf graf--pre graf-after--p">BluetoothHandler</pre><pre name="d9ce" id="d9ce" class="graf graf--pre graf-after--pre">public static final String <em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE </em>= &quot;androidcrypto.measurement.heartrate&quot;;<br>public static final String <em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE_EXTRA </em>= &quot;androidcrypto.measurement.heartrate.extra&quot;;</pre><p name="1dcf" id="1dcf" class="graf graf--p graf-after--pre">The intent is send to the system and there should be registered receiver for this broadcast:</p><pre name="b1f5" id="b1f5" class="graf graf--pre graf-after--p">private void sendMeasurement(@NotNull Intent intent, @NotNull BluetoothPeripheral peripheral ) {<br>    intent.putExtra(<em class="markup--em markup--pre-em">MEASUREMENT_EXTRA_PERIPHERAL</em>, peripheral.getAddress());<br>    context.sendBroadcast(intent);<br>}</pre><p name="7673" id="7673" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">step 3:</strong> define a BroadcastReceiver in MainActivity.java</p><p name="5c27" id="5c27" class="graf graf--p graf-after--p">The receiver checks for the correct measurement and its value, when everything is fine it “delivers” the data by writing the value to a textview.</p><pre name="12df" id="12df" class="graf graf--pre graf-after--p">private final BroadcastReceiver heartRateDataReceiver = new BroadcastReceiver() {<br>    @Override<br>    public void onReceive(Context context, Intent intent) {<br>        HeartRateMeasurement measurement = (HeartRateMeasurement) intent.getSerializableExtra(BluetoothHandler.<em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE_EXTRA</em>);<br>        if (measurement == null) return;<br><br>        measurementValue.setText(String.<em class="markup--em markup--pre-em">format</em>(Locale.<em class="markup--em markup--pre-em">ENGLISH</em>, &quot;%d bpm&quot;, measurement.pulse));<br>    }<br>};</pre><p name="5005" id="5005" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">step 4:</strong> don’t forget to register the BroadcastReceiver at programs startup:</p><pre name="ed32" id="ed32" class="graf graf--pre graf-after--p">MainActivity</pre><pre name="9eda" id="9eda" class="graf graf--pre graf-after--pre">protected void onCreate(Bundle savedInstanceState) {<br>    super.onCreate(savedInstanceState);<br>    setContentView(R.layout.<em class="markup--em markup--pre-em">activity_main</em>);<br>...<br>    registerReceiver(heartRateDataReceiver, new IntentFilter( BluetoothHandler.<em class="markup--em markup--pre-em">MEASUREMENT_HEARTRATE </em>));<br>    ...<br>}</pre><p name="68b2" id="68b2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">step 5: </strong>and unregister the receiver on app’s destroy:</p><pre name="45ea" id="45ea" class="graf graf--pre graf-after--p">protected void onDestroy() {<br>    super.onDestroy();<br>    ...    <br>    unregisterReceiver(heartRateDataReceiver);<br>    ...<br>}</pre><p name="d409" id="d409" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">6. arrange subscriptions (notifications or indications) for some data</strong></p><p name="1715" id="1715" class="graf graf--p graf-after--p">In this example there is no user interaction to enable or disable a notification, the client checks for the services and is trying to enable some common notifications.</p><pre name="f02c" id="f02c" class="graf graf--pre graf-after--p">BluetoothHandler</pre><pre name="d9e3" id="d9e3" class="graf graf--pre graf-after--pre">private final BluetoothPeripheralCallback peripheralCallback = new BluetoothPeripheralCallback() {<br>    @Override<br>    public void onServicesDiscovered(@NotNull BluetoothPeripheral peripheral) {<br>        ...        <br>        }<br>        ...<br>        peripheral.setNotify(<em class="markup--em markup--pre-em">HEART_RATE_SERVICE_UUID</em>, <em class="markup--em markup--pre-em">HEART_RATE_MEASUREMENT_CHARACTERISTIC_UUID</em>, true);<br>        ...<br>    }</pre><p name="6fc2" id="6fc2" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">7. send data from the client to the server (available in a following part)</strong></p><p name="f0c1" id="f0c1" class="graf graf--p graf-after--p">This app does not cover the writing of data from the client to the server, but the method to write data to a characteristic in BluetoothHandler is implemented in this callback:</p><pre name="e4cc" id="e4cc" class="graf graf--pre graf-after--p">BluetoothHandler<br>BluetoothPeripheralCallback</pre><pre name="26fc" id="26fc" class="graf graf--pre graf-after--pre">@Override<br>public void onCharacteristicWrite(@NotNull BluetoothPeripheral peripheral, @NotNull byte[] value, @NotNull BluetoothGattCharacteristic characteristic, @NotNull GattStatus status) {<br>    if (status == GattStatus.<em class="markup--em markup--pre-em">SUCCESS</em>) {<br>        Timber.<em class="markup--em markup--pre-em">i</em>(&quot;SUCCESS: Writing &lt;%s&gt; to &lt;%s&gt;&quot;, <em class="markup--em markup--pre-em">bytes2String</em>(value), characteristic.getUuid());<br>    } else {<br>        Timber.<em class="markup--em markup--pre-em">i</em>(&quot;ERROR: Failed writing &lt;%s&gt; to &lt;%s&gt; (%s)&quot;, <em class="markup--em markup--pre-em">bytes2String</em>(value), characteristic.getUuid(), status);<br>    }<br>}</pre><figure name="fa1a" id="fa1a" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*Zq5_IBp_Xe5j4Ub4EIrcog.png" data-width="500" data-height="388" alt="A measurement is shown after a subscription (notification or indication) is enabled on the server." src="https://cdn-images-1.medium.com/max/800/1*Zq5_IBp_Xe5j4Ub4EIrcog.png"></figure><p name="859a" id="859a" class="graf graf--p graf-after--figure">A final note on the <strong class="markup--strong markup--p-strong">processing of the received data</strong>: in most cases the data is not of values in a single byte but of a byte array structure with flags that need to get checked, so it is important that you know what kind of structure your data is. For common known characteristics there are describing xml-files that give you an idea how to deal with the data. Those xml-files are provided by the Bluetooth-SIG group but are no longer available to the public. There is a GitHub repository that provides some (maybe outdated) descriptions: All of the GATT xml specifications can be found here: <a href="https://github.com/oesmith/gatt-xml" data-href="https://github.com/oesmith/gatt-xml" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/oesmith/gatt-xml</a></p><p name="1739" id="1739" class="graf graf--p graf-after--p">The complete source code for the BleClientBlessedOriginal is available on my GitHub repository: <a href="https://github.com/AndroidCrypto/BleClientBlessedOriginal" data-href="https://github.com/AndroidCrypto/BleClientBlessedOriginal" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/AndroidCrypto/BleClientBlessedOriginal</a></p><p name="edb3" id="edb3" class="graf graf--p graf-after--p graf--trailing">Just follow me to get informed as soon the next part is published.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@androidcrypto" class="p-author h-card">AndroidCrypto</a> on <a href="https://medium.com/p/70f0eea9149b"><time class="dt-published" datetime="2022-10-26T14:40:55.785Z">October 26, 2022</time></a>.</p><p><a href="https://medium.com/@androidcrypto/setup-a-android-bluetooth-low-energy-client-part-1-70f0eea9149b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 27, 2022.</p></footer></article></body></html>